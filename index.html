<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Shooter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js for sound synthesis -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;700&display=swap');

        body {
            font-family: 'Fredoka', sans-serif;
            background: linear-gradient(135deg, #1f4068 0%, #162447 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        #game-container {
            background: #2a3d58;
            border: 8px solid #5d8aa8;
            border-radius: 20px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5), inset 0 0 15px rgba(255, 255, 255, 0.1);
            padding: 15px;
            text-align: center;
            max-width: 90%;
            transition: all 0.3s ease;
        }

        #game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 0 10px;
            color: #ffcc29;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        #game-info div {
            font-size: 1.5rem;
            font-weight: 700;
        }

        #game-canvas {
            background: #394b62;
            display: block;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            cursor: crosshair;
        }

        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px 50px;
            background: #ffcc29;
            color: #162447;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.7);
            font-size: 2rem;
            font-weight: 700;
            z-index: 100;
            display: none;
            text-align: center;
            user-select: none;
            cursor: pointer;
        }

        .bubble {
            border-radius: 50%;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3), inset 0 0 10px rgba(255, 255, 255, 0.5);
            transition: transform 0.1s;
        }

        .bubble:hover {
            transform: scale(1.05);
        }

        #restart-button {
            margin-top: 15px;
            padding: 10px 20px;
            background: #e94560;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 4px #c33a52;
            transition: all 0.1s;
        }

        #restart-button:active {
            box-shadow: 0 2px #c33a52;
            transform: translateY(2px);
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="game-info">
        <div id="score">SCORE: 0</div>
        <div id="lives">SHOTS LEFT: 10</div>
    </div>
    <canvas id="game-canvas"></canvas>
    <button id="restart-button" onclick="initGame()">Restart Game</button>
</div>

<div id="message-box" onclick="initGame()">
    Game Over! Tap to play again.
</div>

<script>
    // --- Global Variables and Constants ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const messageBox = document.getElementById('message-box');
    const scoreDisplay = document.getElementById('score');
    const livesDisplay = document.getElementById('lives');

    // Game Constants
    const CANVAS_WIDTH = 480;
    const CANVAS_HEIGHT = 600;
    const BUBBLE_RADIUS = 20;
    const BUBBLE_DIAMETER = BUBBLE_RADIUS * 2;
    const BUBBLE_GAP = 2;
    const GRID_COLS = 11;
    const GRID_ROWS = 15;
    const SHOOTER_SPEED = 10;
    const MAX_SHOTS = 10;

    // Hexagonal Grid Dimensions (for staggered rows)
    const TILE_WIDTH = BUBBLE_DIAMETER + BUBBLE_GAP;
    const TILE_HEIGHT = Math.sqrt(3) * BUBBLE_RADIUS + BUBBLE_GAP;
    const X_OFFSET = BUBBLE_RADIUS + BUBBLE_GAP / 2;
    const TOP_MARGIN = 50;

    const COLORS = [
        '#e94560', // Red
        '#ffcc29', // Yellow
        '#00adb5', // Cyan
        '#8b5cbf', // Purple
        '#41d3a7', // Green
    ];

    // Game State
    let grid = [];
    let activeBubble = null;
    let nextBubbleColor = null;
    let score = 0;
    let shotsLeft = MAX_SHOTS;
    let gameStatus = 'playing'; // 'playing', 'win', 'lose'
    let animationFrameId;

    // --- Audio Variables ---
    let synthPop;
    let synthShoot;
    let synthDrop;
    let synthAttach; // For when a bubble sticks
    let synthBounce; // For when a bubble hits the wall
    let synthGameEnd; // For game over/win states


    // --- Utility Functions ---

    /**
     * Converts grid indices (row, col) to pixel coordinates (x, y).
     * @param {number} row
     * @param {number} col
     * @returns {{x: number, y: number}}
     */
    function getBubbleCoords(row, col) {
        const isOddRow = row % 2 !== 0;
        let x = col * TILE_WIDTH + BUBBLE_RADIUS;
        if (isOddRow) {
            x += BUBBLE_RADIUS;
        }
        let y = row * TILE_HEIGHT + BUBBLE_RADIUS;

        // Apply global offset
        x += BUBBLE_RADIUS / 2;
        y += TOP_MARGIN;

        return { x, y };
    }

    /**
     * Gets the grid indices (row, col) closest to the given pixel coordinates (x, y).
     * @param {number} x
     * @param {number} y
     * @returns {{row: number, col: number}}
     */
    function getGridIndices(x, y) {
        const row = Math.round((y - TOP_MARGIN - BUBBLE_RADIUS) / TILE_HEIGHT);

        const isOddRow = row % 2 !== 0;
        let x_adj = x - BUBBLE_RADIUS / 2;
        if (isOddRow) {
            x_adj -= BUBBLE_RADIUS;
        }

        const col = Math.round((x_adj - BUBBLE_RADIUS) / TILE_WIDTH);

        return { row: Math.max(0, row), col: Math.max(0, col) };
    }

    /**
     * Checks if a point (x, y) is inside the circle of a bubble.
     */
    function checkCollision(x1, y1, x2, y2) {
        const dx = x1 - x2;
        const dy = y1 - y2;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < BUBBLE_DIAMETER - 2; // -2 for slight tolerance
    }

    // --- Audio Setup ---

    async function initAudio() {
        // Start Tone.js context on user action (important for modern browsers)
        if (Tone.context.state !== 'running') {
            await Tone.start();
        }

        // 1. Pop Sound (PolySynth for multiple simultaneous pops)
        synthPop = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "square" },
            envelope: { attack: 0.001, decay: 0.1, sustain: 0.0, release: 0.1 },
            volume: -10
        }).toDestination();

        // 2. Shoot Sound (PluckSynth for a quick, sharp effect)
        synthShoot = new Tone.PluckSynth({
            attackNoise: 1,
            dampening: 4000,
            resonance: 0.8,
            volume: -10
        }).toDestination();

        // 3. Drop Sound (MembraneSynth for a low thud)
        synthDrop = new Tone.MembraneSynth({
            pitchDecay: 0.01,
            octaves: 2,
            envelope: { attack: 0.001, decay: 0.4, sustain: 0.0, release: 0.01 },
            volume: -15
        }).toDestination();
        
        // 4. Attach/Stick Sound (Soft, low-frequency click)
        synthAttach = new Tone.NoiseSynth({
            noise: { type: 'pink' },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 },
            volume: -20
        }).toDestination();

        // 5. Wall Bounce Sound (Metallic ping)
        synthBounce = new Tone.MetalSynth({
            frequency: 150,
            envelope: { attack: 0.001, decay: 0.05, release: 0.1 },
            harmonicity: 5.1,
            modulationIndex: 32,
            volume: -15
        }).toDestination();

        // 6. Game End Sound (PolySynth for chords - FIX: MembraneSynth doesn't handle chords well)
        synthGameEnd = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sine" },
            envelope: { attack: 0.02, decay: 0.5, sustain: 0.1, release: 1 },
            volume: -8
        }).toDestination();
    }


    // --- Game Setup and State Management ---

    function initCanvas() {
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
    }

    function generateGrid() {
        grid = [];
        const maxRows = 7; // Start with 7 rows of bubbles
        const availableColors = [];

        // Determine which colors are present in the initial grid
        for (let r = 0; r < maxRows; r++) {
            const row = [];
            const cols = r % 2 === 0 ? GRID_COLS : GRID_COLS - 1; // Staggered columns
            for (let c = 0; c < cols; c++) {
                // Generate a random color, but limit it to ensure pop-ability
                let colorIndex;
                if (r < 3) { // Use all colors in the first 3 rows
                    colorIndex = Math.floor(Math.random() * COLORS.length);
                } else { // Use a subset of colors below row 3 to keep it playable
                    colorIndex = Math.floor(Math.random() * 4);
                }

                const color = COLORS[colorIndex];
                row.push({
                    color: color,
                    r: r,
                    c: c,
                    state: 'fixed',
                    x: 0, y: 0 // Will be set in draw
                });
                if (!availableColors.includes(color)) {
                    availableColors.push(color);
                }
            }
            grid.push(row);
        }

        // Ensure the launcher only uses colors currently in the grid
        const validColors = availableColors.length > 0 ? availableColors : COLORS;
        nextBubbleColor = validColors[Math.floor(Math.random() * validColors.length)];
    }

    function spawnNextBubble() {
        const validColors = getValidLauncherColors();
        const color = nextBubbleColor || validColors[Math.floor(Math.random() * validColors.length)];

        activeBubble = {
            x: CANVAS_WIDTH / 2,
            y: CANVAS_HEIGHT - BUBBLE_RADIUS - 10,
            color: color,
            r: -1, c: -1,
            vx: 0, vy: 0,
            state: 'ready',
            isPopping: false
        };

        // Pick the next bubble color immediately
        nextBubbleColor = validColors[Math.floor(Math.random() * validColors.length)];
    }

    /**
     * Finds colors present in the current grid for the launcher.
     */
    function getValidLauncherColors() {
        const presentColors = new Set();
        grid.forEach(row => {
            row.forEach(bubble => {
                if (bubble && bubble.state === 'fixed') {
                    presentColors.add(bubble.color);
                }
            });
        });
        return presentColors.size > 0 ? Array.from(presentColors) : COLORS;
    }


    function updateScore(points) {
        score += points;
        scoreDisplay.textContent = `SCORE: ${score}`;
    }

    function updateLives(decrement = false) {
        if (decrement) {
            shotsLeft--;
        }
        livesDisplay.textContent = `SHOTS LEFT: ${shotsLeft}`;
    }

    async function initGame() {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }

        // Initialize audio context on game start/restart
        await initAudio(); 

        initCanvas();
        generateGrid();
        score = 0;
        shotsLeft = MAX_SHOTS;
        updateScore(0);
        updateLives();
        gameStatus = 'playing';
        messageBox.style.display = 'none';

        spawnNextBubble();
        gameLoop();
    }

    // --- Game Drawing Functions ---

    function drawBubble(x, y, color) {
        ctx.beginPath();
        ctx.arc(x, y, BUBBLE_RADIUS, 0, Math.PI * 2);

        // Radial Gradient for 3D effect
        const gradient = ctx.createRadialGradient(
            x - BUBBLE_RADIUS / 4, y - BUBBLE_RADIUS / 4, BUBBLE_RADIUS / 4,
            x, y, BUBBLE_RADIUS
        );
        gradient.addColorStop(0, 'white');
        gradient.addColorStop(0.5, color);
        gradient.addColorStop(1, 'rgba(0,0,0,0.5)');

        ctx.fillStyle = gradient;
        ctx.fill();

        // White highlight (optional)
        ctx.beginPath();
        ctx.arc(x - BUBBLE_RADIUS / 3, y - BUBBLE_RADIUS / 3, BUBBLE_RADIUS / 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.fill();

        ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    function drawGrid() {
        grid.forEach(row => {
            row.forEach(bubble => {
                if (bubble && bubble.state === 'fixed') {
                    const { x, y } = getBubbleCoords(bubble.r, bubble.c);
                    bubble.x = x;
                    bubble.y = y;
                    drawBubble(x, y, bubble.color);
                }
            });
        });
    }

    function drawShooter() {
        // Draw the shooter base
        ctx.fillStyle = '#1e3046';
        ctx.fillRect(CANVAS_WIDTH / 2 - 50, CANVAS_HEIGHT - 30, 100, 30);
        ctx.beginPath();
        ctx.arc(CANVAS_WIDTH / 2, CANVAS_HEIGHT - 30, 50, Math.PI, Math.PI * 2);
        ctx.fill();

        // Draw the ready bubble
        if (activeBubble && activeBubble.state === 'ready') {
            drawBubble(activeBubble.x, activeBubble.y, activeBubble.color);
        }

        // Draw the next bubble preview
        if (nextBubbleColor) {
            ctx.fillStyle = 'white';
            ctx.fillText('NEXT', CANVAS_WIDTH / 2 + 50, CANVAS_HEIGHT - 10);
            drawBubble(CANVAS_WIDTH / 2 + 100, CANVAS_HEIGHT - BUBBLE_RADIUS - 10, nextBubbleColor);
        }

        // Draw the moving bubble
        if (activeBubble && activeBubble.state === 'moving') {
            drawBubble(activeBubble.x, activeBubble.y, activeBubble.color);
        }
    }

    function draw() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        drawGrid();
        drawShooter();

        // Draw the "Game Over" line
        ctx.strokeStyle = 'rgba(255, 50, 50, 0.7)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, TOP_MARGIN + 9 * TILE_HEIGHT); // 9 rows down is the danger zone
        ctx.lineTo(CANVAS_WIDTH, TOP_MARGIN + 9 * TILE_HEIGHT);
        ctx.stroke();
    }

    // --- Game Logic: Movement and Collision ---

    function updateMovingBubble() {
        if (!activeBubble || activeBubble.state !== 'moving') return;

        // 1. Move the bubble
        activeBubble.x += activeBubble.vx;
        activeBubble.y += activeBubble.vy;

        // 2. Wall collision (bounce off left/right)
        if (activeBubble.x - BUBBLE_RADIUS < 0 || activeBubble.x + BUBBLE_RADIUS > CANVAS_WIDTH) {
            activeBubble.vx *= -1;
            // Play Bounce Sound
            if (synthBounce) {
                synthBounce.triggerAttackRelease('32n', Tone.now());
            }
        }

        // 3. Ceiling collision (attach)
        if (activeBubble.y - BUBBLE_RADIUS < TOP_MARGIN) {
            handleCollision(activeBubble.x, activeBubble.y, 0, 0); // Attach to the ceiling
            return;
        }

        // 4. Grid collision (check against all fixed bubbles)
        for (let r = 0; r < grid.length; r++) {
            for (let c = 0; c < grid[r].length; c++) {
                const fixedBubble = grid[r][c];
                if (fixedBubble && fixedBubble.state === 'fixed') {
                    if (checkCollision(activeBubble.x, activeBubble.y, fixedBubble.x, fixedBubble.y)) {
                        handleCollision(activeBubble.x, activeBubble.y, fixedBubble.x, fixedBubble.y);
                        return;
                    }
                }
            }
        }
    }

    /**
     * Handles collision by placing the active bubble into the nearest grid slot.
     * @param {number} collisionX - The x-coord of the moving bubble at collision.
     * @param {number} collisionY - The y-coord of the moving bubble at collision.
     */
    function handleCollision(collisionX, collisionY) {
        // Find the closest empty grid slot to the collision point
        const { row, col } = getGridIndices(collisionX, collisionY);

        // Check if the calculated slot is valid and empty
        if (row < GRID_ROWS && row >= 0) {
            const isOddRow = row % 2 !== 0;
            const maxCols = isOddRow ? GRID_COLS - 1 : GRID_COLS;

            // Ensure the column is within bounds and the cell is empty
            if (col < maxCols && col >= 0 && (!grid[row] || !grid[row][col])) {
                // If row doesn't exist, create it (shouldn't happen with the ceiling collision logic)
                if (!grid[row]) {
                    grid[row] = Array(GRID_COLS).fill(null);
                }
                if (!grid[row][col]) {
                    activeBubble.r = row;
                    activeBubble.c = col;
                    activeBubble.state = 'fixed';
                    grid[row][col] = activeBubble;
                    activeBubble = null;
                    
                    // Play Attach Sound (before checking for a pop)
                    if (synthAttach) {
                        synthAttach.triggerAttackRelease('16n');
                    }


                    // Start the chain reaction
                    processAttachment(row, col);

                    // Check for Game Over
                    if (row > 9) {
                        endGame('lose');
                        return;
                    }

                    // Respawn next bubble
                    spawnNextBubble();
                    updateLives(true);
                    return;
                }
            }
        }

        // If collision failed to find an empty adjacent slot (e.g., hit between two),
        // we revert the position slightly and try again to find the closest valid spot.
        // In a complex game, this would involve iterative searching of neighbors.
        activeBubble.state = 'ready';
        activeBubble.vx = 0;
        activeBubble.vy = 0;
        updateLives(true);
    }

    // --- Game Logic: Popping and Dropping ---

    /**
     * Gets the grid neighbors for a given cell (r, c) based on the hexagonal pattern.
     */
    function getNeighbors(r, c) {
        const neighbors = [];
        const isOddRow = r % 2 !== 0;

        // We only need 6 specific neighbors for the grid layout
        const offsets = isOddRow
            ? [[-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0], [1, 1]] // Odd row
            : [[-1, -1], [-1, 0], [0, -1], [0, 1], [1, -1], [1, 0]]; // Even row


        offsets.forEach(([dr, dc]) => {
            const nr = r + dr;
            const nc = c + dc;

            if (nr >= 0 && nr < GRID_ROWS && grid[nr] && nc >= 0 && nc < grid[nr].length) {
                if (grid[nr][nc] && grid[nr][nc].state === 'fixed') {
                    neighbors.push(grid[nr][nc]);
                }
            }
        });

        return neighbors;
    }

    function processAttachment(r, c) {
        const targetBubble = grid[r][c];
        if (!targetBubble) return;

        const cluster = findBubbleCluster(r, c, targetBubble.color, true);

        if (cluster.length >= 3) {
            // Pop the bubbles!
            cluster.forEach(bubble => {
                grid[bubble.r][bubble.c] = null;
            });
            updateScore(cluster.length * 10);
            
            // Play Pop Sound
            if (synthPop) {
                // Play different notes based on the size of the pop
                const note = cluster.length > 5 ? 'C6' : 'C5';
                synthPop.triggerAttackRelease(note, '8n');
            }
        }

        // Check for floating bubbles
        dropFloatingBubbles();

        // Check for win condition
        checkWinCondition();
    }

    /**
     * Finds a connected cluster of same-colored bubbles using Breadth-First Search (BFS).
     * @param {number} startR - Starting row.
     * @param {number} startC - Starting column.
     * @param {string} color - The color to match.
     * @param {boolean} onlySameColor - If true, only checks for bubbles of the same color.
     * @returns {Array<Object>} - Array of connected bubbles.
     */
    function findBubbleCluster(startR, startC, color, onlySameColor) {
        const queue = [{ r: startR, c: startC }];
        const visited = new Set(`${startR},${startC}`);
        const cluster = [];

        while (queue.length > 0) {
            const { r, c } = queue.shift();
            const currentBubble = grid[r] && grid[r][c];

            if (!currentBubble || currentBubble.state !== 'fixed') continue;

            if (onlySameColor && currentBubble.color !== color) continue;

            cluster.push(currentBubble);

            const neighbors = getNeighbors(r, c);

            neighbors.forEach(neighbor => {
                const key = `${neighbor.r},${neighbor.c}`;
                if (!visited.has(key)) {
                    visited.add(key);
                    queue.push({ r: neighbor.r, c: neighbor.c });
                }
            });
        }
        return cluster;
    }

    /**
     * Checks all bubbles for connectivity to the top (r=0) and drops non-connected ones.
     */
    function dropFloatingBubbles() {
        const connectedBubbles = new Set();
        const topRow = grid[0] || [];
        let droppedCount = 0;

        // 1. Find all bubbles connected to the ceiling
        topRow.forEach(bubble => {
            if (bubble && bubble.state === 'fixed') {
                const cluster = findBubbleCluster(bubble.r, bubble.c, null, false); // find all connected, regardless of color
                cluster.forEach(b => connectedBubbles.add(`${b.r},${b.c}`));
            }
        });

        // 2. Iterate through all bubbles and remove those not in the connected set
        for (let r = 0; r < grid.length; r++) {
            for (let c = 0; c < grid[r].length; c++) {
                const bubble = grid[r][c];
                if (bubble && bubble.state === 'fixed' && !connectedBubbles.has(`${r},${c}`)) {
                    grid[r][c] = null; // Remove it from the grid
                    // Optional: add score for drops
                    updateScore(5);
                    droppedCount++;
                }
            }
        }
        
        // Play Drop Sound if bubbles were dropped
        if (droppedCount > 0 && synthDrop) {
            // Play a low thud sound
            synthDrop.triggerAttackRelease('C1', '8n');
        }
    }

    function checkWinCondition() {
        let bubblesRemaining = 0;
        grid.forEach(row => {
            row.forEach(bubble => {
                if (bubble && bubble.state === 'fixed') {
                    bubblesRemaining++;
                }
            });
        });

        if (bubblesRemaining === 0) {
            endGame('win');
        }
    }

    function endGame(result) {
        gameStatus = result;
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }
        
        // Play Game End Sound
        if (synthGameEnd) {
            if (result === 'win') {
                // Play a celebratory chord
                synthGameEnd.triggerAttackRelease(['C4', 'E4', 'G4', 'C5'], '1', Tone.now());
            } else {
                // Play a simple loss tone
                synthGameEnd.triggerAttackRelease(['C3', 'G2'], '1', Tone.now());
            }
        }

        messageBox.style.display = 'block';
        if (result === 'win') {
            messageBox.textContent = `You Won! Final Score: ${score}`;
            messageBox.style.backgroundColor = '#41d3a7';
        } else {
            messageBox.textContent = `Game Over! Final Score: ${score}. Tap to play again.`;
            messageBox.style.backgroundColor = '#e94560';
        }
    }

    // --- Input Handler ---

    function handleShoot(event) {
        if (gameStatus !== 'playing' || !activeBubble || activeBubble.state !== 'ready' || shotsLeft <= 0) return;

        const rect = canvas.getBoundingClientRect();
        const clientX = event.clientX;
        const clientY = event.clientY;

        // Scale coordinates if canvas is resized
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const mouseX = (clientX - rect.left) * scaleX;
        const mouseY = (clientY - rect.top) * scaleY;

        // Calculate angle between launcher and mouse position
        const dx = mouseX - activeBubble.x;
        const dy = mouseY - activeBubble.y;
        let angle = Math.atan2(dy, dx);

        // Limit angle to prevent shooting backwards
        const minAngle = Math.PI * 0.05; // 9 degrees
        const maxAngle = Math.PI * 0.95; // 171 degrees

        if (angle > -minAngle && angle <= 0) {
            angle = -minAngle;
        } else if (angle < -maxAngle) {
            angle = -maxAngle;
        } else if (angle > 0) {
            // For Bubble Shooter, we typically only shoot up (negative Y velocity)
            // If mouse is below the shooter, we should clamp to a sensible upward angle.
            // A simple check to ensure it's pointing up:
            if (mouseY > activeBubble.y) {
                 // Mouse is below shooter, cap the angle to straight up
                 angle = -Math.PI / 2;
            }
        }


        // Set velocity components
        activeBubble.vx = SHOOTER_SPEED * Math.cos(angle);
        activeBubble.vy = SHOOTER_SPEED * Math.sin(angle);
        activeBubble.state = 'moving';
        
        // Play Shoot Sound
        if (synthShoot) {
            synthShoot.triggerAttackRelease('A4', '16n');
        }
    }

    canvas.addEventListener('click', handleShoot);


    // --- Game Loop ---

    function gameLoop() {
        if (gameStatus !== 'playing') return;

        updateMovingBubble();
        draw();

        if (shotsLeft <= 0 && activeBubble && activeBubble.state === 'ready') {
            endGame('lose');
            return;
        }

        animationFrameId = requestAnimationFrame(gameLoop);
    }

    // Initialize the game when the script loads
    window.onload = initGame;
</script>
</body>
</html>
